'''
File: dataset_conversion.py

This file defines DatasetConversion class that helps convert between .txt files and dataset for training/testing.
Class instance can be generated by dc = DatasetConversion(directory_path, sep_by_type),
where sep_by_type is either 'word' or 'char' depending on whether you want to
treat each word (meaning the group of notes simultaneously being played at each timestep)
or each character (literally each character in the .txt string) as the unit of input.
'''

## import statements
import numpy as np

import sys

import os

import random

import utils



## constants
SEPARATOR = chr(utils.NOTES_SIZE) # separator between each timestep in .txt file
DEFAULT_NUM_INPUT = 16 # default number of unit input to be inserted at once
DEFAULT_NUM_OUTPUT = 1 # default number of unit output to be taken at once

MIDI_EXTS = ['.mid', '.midi']
TXT_EXTS = ['.txt']

## class definition
class DatasetConversion(object):

    def __init__(self, directory_path='.', sep_by_type='word'):
        self.data_to_int = {} # dict{str : int}, mapping each unique data to an integer
        self.int_to_data = {} # dict{int : str}, reverse of data_to_int
        self.dir_path = directory_path
        if sep_by_type in ['word', 'char']:
            self.sep_by_type = sep_by_type
        else:
            # error
            print("Param sep_by_type should be specified as either 'word' or 'char'")
            exit(1)

    def midi_to_txt(self):
        '''
        Class function: midi_to_txt

        Input--
            None
        Output--
            None

        This file converts all MIDI files in the class directory into .txt files for compression.
        Format consistent with .txt files used in utils.py
        '''
        midifile_list = utils.get_files_by_ext(self.dir_path, MIDI_EXTS)

        for midifile in midifile_list:
            utils.midi_to_txt(midifile, input_dir=self.dir_path, output_dir=self.dir_path)

    def txt_to_dataset(self, num_input=None, num_output=None):
        '''
        Class function: txt_to_dataset

        Input--
            num_input (int) : number of inputs to be considered at a time
            num_output (int): number of outputs to be taken at a time
        Output--
            Two np.ndarrays X, Y, of shape (n_examples, num_input, 1) to be fed to LSTM.

        This function takes in a directory of .txt files and converts the data to a dataset format for LSTM.
        '''
        window_step_size = 1

        num_input_size = DEFAULT_NUM_INPUT if num_input is None else num_input
        num_output_size = DEFAULT_NUM_OUTPUT if num_output is None else num_output

        # generates a list of all text files in the directory
        txtfile_list = utils.get_files_by_ext(self.dir_path, TXT_EXTS)

        # calculate the total amount of data per each feed
        total_size_per_feed = num_input_size + num_output_size

        # initialize
        inputs = []
        outputs = []

        for file in txtfile_list:
            # get the total path
            filepath = os.path.join(self.dir_path, file)

            with open(filepath, 'r', encoding="utf-8") as in_f:
                data = in_f.read().strip('\n')
                if self.sep_by_type == 'word':
                    # if reading by word, split by the timestep separator (defined in utils.py)
                    notes_split = data.split(SEPARATOR)
                    notes_split = [s[:len(s) // 2] for s in notes_split]
                    notes_split = [s for s in notes_split if s != '']
                elif self.sep_by_type == 'char':
                    # if reading by character, just split each individual character
                    notes_split = data.split(SEPARATOR)
                    notes_split = [s[:len(s) // 2] for s in notes_split]
                    notes_split = [s for s in notes_split if s != '']
                    notes_split = SEPARATOR.join(notes_split)
                    notes_split = list(notes_split)

                # for all possible continuous combinations of size total_size_per_feed:
                for idx in range(0, len(notes_split) - total_size_per_feed  + 1, window_step_size):
                    if random.random() > 0.2:
                        continue
                    # take the first num_input_size data as input
                    input_x = notes_split[idx : idx + num_input_size]
                    # take the later num_output_size data as output
                    output_y = [notes_split[idx + num_input_size]]

                    inputs.append(input_x)
                    outputs.append(output_y)

        # flatten lists and join, to compute the set of vocabulary
        possible_X = [comb for input_x in inputs for comb in input_x]
        possible_Y = [comb for output_y in outputs for comb in output_y]
        possible_all = possible_X + possible_Y
        # sort so that similar vocabulary are nearby
        # (e.g., if reading by word, two combinations may both start with char equivalent to 'C')
        possible_all = sorted(list(set(possible_all)))
        # assign index to each
        self.data_to_int = dict([(comb, i) for i, comb in enumerate(possible_all)])
        self.int_to_data = dict([(i, comb) for i, comb in enumerate(possible_all)])
        # convert combinations to floats
        input_ints = [[self.data_to_int[comb]/len(self.data_to_int) for comb in input_x] for input_x in inputs]
        # output_ints = [[self.data_to_int[comb]/len(self.data_to_int) for comb in output_y] for output_y in outputs]

        output_ints = np.zeros((len(outputs), len(self.data_to_int)), dtype=bool)
        for i in range(len(outputs)):
            output_ints[i, self.data_to_int[possible_Y[i]]] = True

        # reshape the data to fit LSTM input format
        X = np.array(input_ints).reshape(len(inputs), num_input_size, 1)
        # Y = np.array(output_ints).reshape(len(outputs), num_output_size, 1)
        Y = output_ints

        return X, Y, len(self.data_to_int)

    def dataset_to_str(self, Y):
        '''
        Class function: dataset_to_str

        Input--
            Y(np.ndarray) : shape (n_examples, num_output_size, 1)
        Output--
            str : Y converted into a string format (consistent with utils.py)

        This function converts the output from LSTM to a text string format,
        so that they can subsequently be converted into MIDI files and played.
        '''
        # round the values to the nearest index assigned to vocabulary
        Y = np.around(Y * len(self.int_to_data))
        # make sure that they don't go out of MIDI range (0-127)
        Y = np.minimum(np.maximum(Y, 0), len(self.int_to_data) - 1)
        # flatten list
        Y = Y.flatten().tolist()
        # convert to text format
        Y_str = [self.int_to_data[Y[i]] for i in range(len(Y))]
        if self.sep_by_type == 'word':
            str_output = SEPARATOR.join(Y_str)
        elif self.sep_by_type == 'char':
            str_output = ''.join(Y_str)

        return str_output

    def str_to_midi(self, text_string, filename=None):
        '''
        Class function: str_to_midi

        Input--
            text_string (str) : string representation (consistent with utils.py) of MIDI notes
        Output--
            filename (str) : name of created MIDI file name

        This function convers our string representation of MIDI notes (likely outputted from model)
        to a playable .mid file.
        '''
        arr = utils.str_to_np(text_string, is_file_conversion=False)
        return utils.arr_to_midi(arr, filename)

